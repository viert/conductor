<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Inventoree API</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,500" rel="stylesheet">
  <style>
    h1,
    h2,
    h3,
    h4,
    h5 {
      font-family: 'PT Sans', OpenSans, 'Helvetica Neue', Helvetica, Ubuntu, Arial, sans-serif;
    }

    body {
      background: #eeeeee;
      padding: 0;
      margin: 0;
      font-family: Roboto;
      font-weight: 300;
      font-size: 14px;
    }

    main {
      max-width: 840px;
      margin: 0 auto;
      border-left: 1px solid #cccccc;
      border-right: 1px solid #cccccc;
      padding: 20px;
      background: white;
      min-height: 100vh;
      box-sizing: border-box;
    }

    p {
      font-weight: 300;
      font-family: Roboto;
      font-size: 14px;
    }

    h1,
    h2,
    h3,
    h4,
    h5 {
      /* margin: 0 0 8px; */
    }

    section {
      margin: 20px 0;
    }

    p {
      line-height: 1.4em;
    }

    code {
      font-family: 'PT Sans Mono', 'OpenSans Mono', Monaco, 'Ubuntu Mono', Consolas, 'Courier New', monospace;
      font-size: 12px;
      padding: 1px 4px;
      color: #4444cc;
      background: #eeeeee;
      margin-bottom: 2px;
      display: inline-block;
    }

    pre>code {
      padding: 4px;
      border: 1px solid #cccccc;
    }

    code.handler {
      font-size: 18px;
      background: #eeeeee;
      padding: 4px;
      border: 1px solid gray;
      margin: 12px auto 0 0;
      display: inline-block;
    }

    .warning {
      background: #ffffcc;
      padding: 2px 4px;
      color: #444400;
    }

    code.handler a {
      color: black;
    }

    hr {
      border-bottom: 1px solid #cccccc;
      border-top: none;
    }

    ul.toc,
    ul.fieldlist {
      list-style: none;
      padding-left: 20px;
    }
  </style>
</head>

<body>
  <main>
    <h1 style="margin-top: 0;">Inventoree API documentation</h1>
    <small>Inventoree version 6.11
      <a href="https://github.com/viert/inventoree">Source code</a>
    </small>
    <h3>Table of contents</h3>
    <ul class="toc">
      <li>
        <a href="#account">Account</a>
      </li>
      <li>
        <a href="#actions">Actions</a>
      </li>
      <li>
        <a href="#datacenters">Datacenters</a>
      </li>
      <li>
        <a href="#groups">Groups</a>
      </li>
      <li>
        <a href="#hosts">Hosts</a>
      </li>
      <li>
        <a href="#open">Open</a>
      </li>
      <li>
        <a href="#work_groups">WorkGroups</a>
      </li>
      <li>
        <a href="#users">Users</a>
      </li>
    </ul>
    <section>
      <a name="account"></a>
      <h2>Account API</h2>
      <p>Most of Inventoree handlers require authorization so Account API is the thing you should definitely start
        from. As
        the web ui uses the same API, users can be both authorized with cookie when using web UI or authentification
        token.
        Authentification tokens may be passed using
        <code>X-Api-Auth-Token</code> HTTP header passing the token as is or using
        <code>Authorization</code> header prefixing the token with
        <b>Token </b> string, i.e.
        <br />
        <code>X-Api-Auth-Token: 7b637aa4-8112-4d01-af60-4f749d66665a</code> or
        <br />
        <code>Authorization: Token 7b637aa4-8112-4d01-af60-4f749d66665a</code> whatever you prefer.
      </p>
      <hr>
      <code class="handler">GET
        <a href="/api/v1/account/me" target="_blank">
         /api/v1/account/me
        </a>
      </code>
      <p>
        Gives an information on current user logged in.
      </p>
      <pre><code>{
    "data": {
        "_id": "5a056884cd2b4f1f9626fa3a", 
        "auth_token": "a34e8aa1-25d1-4e32-a24b-e57acb872e58", 
        "avatar_url": "", 
        "created_at": "Fri, 10 Nov 2017 08:51:14 GMT", 
        "custom_data": {}, 
        "email": "", 
        "ext_id": null, 
        "first_name": "", 
        "last_name": "", 
        "supervisor": true, 
        "updated_at": "Wed, 07 Mar 2018 13:38:02 GMT", 
        "username": "admin"
    }
}</code></pre>
      <p>
        <code>ext_id</code> and
        <code>custom_data</code> fields are filled in if you're using an external auth plugin and if the plugin
        explicitly uses it.
        <code>ext_id</code> must be used by any external auth as the field is indexed and used to find user by an ID
        provided by ext auth provider.
        While
        <code>custom_data</code> is an object with additional fields which may be filled by provider although it's
        completely optional.
      </p>
      <hr>
      <code class="handler">POST 
        <a href="/api/v1/account/authenticate" target="_blank">
          /api/v1/account/authenticate
        </a>
      </code>
      <p>
        Authenticates user with a login and a password fields of JSON body.
      </p>
      <pre><code>{ 
  "username": "admin",
  "password": "SuP3r$ecR3t" 
}</code></pre>
      <p>
        Passwords are stored encrypted and being used only by built-in auth mechanism. If you're using ext auth
        provider, no passwords
        are stored. Passwords must never be reached by any API handler even in encrypted form.
      </p>
      <p>
        Handler with response with the user data when authentication went well
      </p>
      <pre><code>{
    "data": {
        "_id": "5a056884cd2b4f1f9626fa3a", 
        "auth_token": "a34e8aa1-25d1-4e32-a24b-e57acb872e58", 
        "avatar_url": "", 
        "created_at": "Fri, 10 Nov 2017 08:51:14 GMT", 
        "custom_data": {}, 
        "email": "", 
        "ext_id": null, 
        "first_name": "", 
        "last_name": "", 
        "supervisor": true, 
        "updated_at": "Wed, 07 Mar 2018 13:38:02 GMT", 
        "username": "admin"
    },
    "status": "authenticated"
}</code></pre>
      <p>
        Handler will response with
        <code>AuthenticationError</code> if user doesn't exist or password doesn't match.
      </p>

      <hr>
      <code class="handler">POST
        <a href="/api/v1/account/logout" target="_blank">
          /api/v1/account/logout
        </a>
      </code>
      <p>
        Clears the user's session as well as deletes the session cookie. Doesn't mean much when requesting using auth
        token.
      </p>

    </section>
    <section>
      <a name="actions"> </a>
      <h2>Actions API</h2>
      <p>
        Actions API provides action logging capabilities of Inventoree i.e. every action done by user is logged and can
        be read using
        Actions API. All the handlers require auth and all of them are read-only. Actions are created using internal
        mechanisms
        and this should not be interfered from the outside.
      </p>
      <code class="handler">GET
        <a href="/api/v1/actions/" target="_blank">
          /api/v1/actions/
        </a>
      </code>
      <p>
        Provides a paginated list of actions. Read more about pagination in
        <a href="#pagination">Pagination</a> section of this doc.
      </p>
      <p>
        Action list can be filtered out using the following query parameters:
      </p>
      <p>
        <code>_users</code> accepts a comma-separated list of usernames. This will show only actions done by particular
        users.
      </p>
      <p>
        <code>_action_types</code> accepts a comma-separated list of action types. Only actions of those types will be
        listed. For the list of available
        action types please refer to
        <code>/api/v1/actions/action_types</code> handler description below.
      </p>
      <hr />
      <code class="handler">GET
        <a href="/api/v1/actions/action_types" target="_blank">
          /api/v1/actions/action_types
        </a>
      </code>
      <p>This handler responses with a complete list of available action types. This is tipically used by the UI to
        autosuggest
        an action type in a type-ahead input field. However it may be handy for an automation scripts used for an
        action
        logging audit</p>
    </section>
    <section>
      <a name="datacenters"> </a>
      <h2>Datacenters API</h2>
      <p>
        Datacenters API lets user manipulate datacenters. All the handlers require auth.
      </p>
      <code class="handler">GET
        <a href="/api/v1/datacenters/" target="_blank">
          /api/v1/datacenters/
        </a>
      </code>
      <p>
        Provides a paginated list of datacenters. Read more about pagination in
        <a href="#pagination">Pagination</a> section of this doc. List may be filtered by datacenter name using
        <code>_filter</code> query parameter. This accepts a string which is used as a prefix of datacenter name.
        Filters shorter than 2 symbols
        are ignored. Filters may be a quite heavy feature as they use regexp full scan on a MongoDB collection.
      </p>
      <p>
        <code>_fields</code> field helps to reduce size of the response allowing you to choose which fields to show.
        Accepts comma-separated
        list of field names. Available datacenter fields are:
        <ul class="fieldlist">
          <li>
            <code>_id</code> is the unique id of the datacenter
          </li>
          <li>
            <code>name</code> is the unique name
          </li>
          <li>
            <code>description</code> speaks for itself. Can be null.
          </li>
          <li>
            <code>created_at</code> - datetime of the model creation.
          </li>
          <li>
            <code>updated_at</code> - datetime of the last model update.
          </li>
          <li>
            <code>parent_id</code> - id of the parent datacenter. When null i.e. the datacenter has no parent, that
            means the datacenter is one
            of root DCs.
          </li>
          <li>
            <code>parent</code> - the parent datacenter itself as an object. Has only the default fields list which is
            not affected by
            <code>_fields</code> param. Can be null.
            <span class="warning">This is an additional database lookup</span>
          </li>
          <li>
            <code>root_id</code> - the id of the root dc for the datacenter i.e. the highest parent. Can be null if the
            DC has no parent.
          </li>
          <li>
            <code>root</code> - the whole root datacenter as an object. Has only the default fields list which is not
            affected by
            <code>_fields</code> param. Can be null.
            <span class="warning">This is an additional database lookup</span>
          </li>
          <li>
            <code>child_ids</code> - the list of ids of direct children.
          </li>
          <li>
            <code>children</code> - the list of children as objects.
            <span class="warning">This is an additional database lookup</span>
          </li>
          <li>
            <code>all_children</code> - the whole children tree recursively represented as a list of objects.
            <span class="warning">This can be a lot of additional database lookups depending on your datacenter
              structure. Can be a heavy request.</span>
          </li>
          <li>
            <code>is_root</code> - boolean field returning
            <code>true</code> only if the datacenter has no parents.
          </li>
          <li>
            <code>hosts</code> - the list of hosts (as objects) directly located in the datacenter.
            <span class="warning">This is an additional database lookup</span>
          </li>
          <li>
            <code>all_hosts</code> - this is a recursively created list of all the hosts located in the datacenter and
            all its children.
            <span class="warning">This can be a lot of additional database lookups depending on your datacenter
              structure. Can be a heavy request.</span>
          </li>

        </ul>
      </p>
      <p>
        The default example response (without
        <code>_filter</code> and
        <code>_fields</code> params) will look like:
      </p>
      <pre><code>{
  "count": 3, 
  "data": [
    {
      "_id": "5a058c92cd2b4f254f02fa73", 
      "child_ids": [], 
      "created_at": "Fri, 10 Nov 2017 11:25:06 GMT", 
      "description": "B0 Jakarta Datacenter", 
      "name": "b0", 
      "parent_id": null, 
      "root_id": null, 
      "updated_at": "Thu, 22 Feb 2018 09:43:02 GMT"
    }, 
    {
      "_id": "5a0593a2cd2b4f26297d2921", 
      "child_ids": [
        "5a0593becd2b4f26297d2924"
      ], 
      "created_at": "Fri, 10 Nov 2017 11:55:14 GMT", 
      "description": null, 
      "name": "dc1", 
      "parent_id": null, 
      "root_id": null, 
      "updated_at": "Thu, 12 Apr 2018 07:10:09 GMT"
    }, 
    {
      "_id": "5a0593becd2b4f26297d2924", 
      "child_ids": [], 
      "created_at": "Fri, 10 Nov 2017 11:55:42 GMT", 
      "description": null, 
      "name": "dc1.1", 
      "parent_id": "5a0593a2cd2b4f26297d2921", 
      "root_id": "5a0593a2cd2b4f26297d2921", 
      "updated_at": "Tue, 13 Feb 2018 11:18:52 GMT"
    }
  ],
  "page": 1, 
  "total_pages": 1
}</code></pre>
      <p>
        Datacenter can and should be structured as a tree. They should be interpreted as
        <i>locations</i>. This will allow to filter out hosts by countries, cities, datacenters, and even racks. Such
        kind of
        tree is organized by
        <code>parent_id</code>,
        <code>root_id</code>, and
        <code>child_ids</code> fields of a datacenter model.
      </p>
      <hr />
      <code class="handler">GET
        <a href="/api/v1/datacenters/:id" target="_blank">
          /api/v1/datacenters/:id
        </a>
      </code>
      <p>
        Provides the same functionality as list of datacenters but for only one datacenter identified via
        <code>:id</code> param which can be both
        <code>_id</code> or
        <code>name</code> as they are both unique. The result behaves the same, that is, returns a list of one element
        in
        <code>data</code> field of the response.
      </p>
      <hr />
      <code class="handler">POST
        <a href="/api/v1/datacenters/" target="_blank">
          /api/v1/datacenters/
        </a>
      </code>
      <p>
        Creates a new datacenter out of JSON payload. The only required field is
        <code>name</code>. Provide
        <code>parent_id</code> to make the new datacenter a child of an existing one.
        <code>_fields</code> query param is valid for this request so you're able to filter out datacenter's fields in
        the response.
      </p>
      <hr />
      <code class="handler">PUT
        <a href="/api/v1/datacenters/:id" target="_blank">
          /api/v1/datacenters/:id
        </a>
      </code>
      <p>
        Updates datacenter identified by
        <code>:id</code> param (which can be either
        <code>_id</code> or
        <code>name</code>) with a JSON payload. Provide
        <code>parent_id</code> field to set the parent of the datacenter you're updating (children of the new parent
        are filled up automatically)
        if it has no parent. Be aware that you can't move the datacenter from one parent to another as this is a
        two-step
        process (first unset and then set the new one) and as it might make an exception during any of those steps,
        it's
        been decided to make this process a special handler. (See /api/v1/datacenters/:id/set_parent)
        <code>_fields</code> query param is valid for this request so you're able to filter out datacenter's fields in
        the response.
      </p>
      <hr />
      <code class="handler">DELETE
        <a href="/api/v1/datacenters/:id" target="_blank">
          /api/v1/datacenters/:id
        </a>
      </code>
      <p>Deletes the datacenter identified by
        <code>:id</code> param (which can be either
        <code>_id</code> or
        <code>name</code>). Returns the datacenter just been deleted.
        <code>_fields</code> param is also relevant for this handler.
      </p>
      <hr />
      <code class="handler">PUT
        <a href="/api/v1/datacenters/:id" target="_blank">
          /api/v1/datacenters/:id/set_parent
        </a>
      </code>
      <p>
        Sets the datacenter's parent using
        <code>parent_id</code> field of the JSON payload. If it's not there or it's null, the parent will be unset.
        Children of both new and old
        parents will be set automatically.
      </p>
    </section>
    <section>
      <a name="groups"></a>
      <h2>Groups API</h2>
      <p>
        Groups API allows user to manipulate groups. Every group must be included into a workgroup. Group without a
        workgroup is not valid. Group may have a number of parents and a number of children, thus, it's not a tree but a graph or to be
        more precise a set of graphs as groups in one workgroup can not be connected to groups in other workgroup.
      </p>
      <p>
        Groups can have tags and custom fields attached to them. Tags are arbitrary string items while custom fields
        are objects
        in particular format:
        <code>{ "key": ..., "value": ... }</code>
      </p>
      <p>
        Here's a couple of example use-cases of tags and custom fields: let's say you have a group of servers with
        different OSes
        installed by historical reasons. In this case you can make a group like
        <i>my_super_service_frontend</i> and attach a custom field to it like this:
        <code>{ "os_type": "debian" }</code>. For a group
        <i>my_super_service_db</i> you use CentOS as you run OracleDB on those servers, so you attach
        <code>{ "os_type": "centos" }</code> to that group. All those custom fields are inherited group by group down
        to the end servers. So requesting info
        on a particular host using
        <a href="#hosts">Hosts API</a>, you will get
        <code>os_type</code> custom field attached to the host.
      </p>
      <p>
        In other case you want to somehow indicate some hosts which have SSD in them. If you use a custom field like
        <code>ssd_installed: true</code> you'll anyway face the problem: now you have to attach
        <code>ssd_installed: false</code> to every host not having SSDs which is not very convenient. There's a way
        out: just attach a tag
        <code>ssd</code> to hosts or a group of hosts having SSDs.
      </p>
      <code class="handler">GET
        <a href="/api/v1/groups/" target="_blank">
          /api/v1/groups/
        </a>
      </code>
      <p>
        Provides a paginated list of groups. Read more about pagination in
        <a href="#pagination">Pagination</a> section of this doc. List may be filtered by group name using
        <code>_filter</code> query parameter. This accepts a string which is used as a prefix of group name. Filters
        shorter than 2 symbols are
        ignored. Filters may be a quite heavy feature as they use regexp full scan on a MongoDB collection.
      </p>
      <p>
        <code>_fields</code> field helps to reduce size of the response allowing you to choose which fields to show.
        Accepts comma-separated
        list of field names. Available group fields are:
        <ul class="fieldlist">
          <li>
            <code>_id</code> - a unique id of the group
          </li>
          <li>
            <code>name</code> - a unique name of the group
          </li>
          <li>
            <code>description</code> - a description of the group. Can be null.
          </li>
          <li>
            <code>created_at</code> - datetime of the model creation.
          </li>
          <li>
            <code>updated_at</code> - datetime of the last model update.
          </li>
          <li>
            <code>work_group_id</code> - id of the workgroup group belongs to
          </li>
          <li>
            <code>parent_ids</code> - a list of group's parents ids
          </li>
          <li>
            <code>child_ids</code> - a list of group's children ids
          </li>
          <li>
            <code>tags</code> - a list of tags attached to the group directly
          </li>
          <li>
            <code>custom_fields</code> - a list of custom fields attached to the group directly.
          </li>
          <li>
            <code>hosts</code> - a list of hosts attached to the group directly.
            <span class="warning">This is an additional database lookup</span>
          </li>
          <li>
            <code>host_ids</code> - a list of ids of hosts attached to the group directly.
            <span class="warning">This is an additional database lookup</span>
          </li>
          <li>
            <code>empty</code> - a boolean field indicating that the group has neither children nor hosts to it.
            <span class="warning">This is an additional indexed database lookup as the hosts are located in another
              MongoDB collection</span>
          </li>
          <li>
            <code>parents</code> - a list of direct parents of the group as objects.
            <span class="warning">This is an additional database lookup</span>
          </li>
          <li>
            <code>children</code> - a list of direct children of the group as objects.
            <span class="warning">This is an additional database lookup</span>
          </li>
          <li>
            <code>work_group</code> - a workgroup the group belongs to as an object.
            <span class="warning">This is an additional database lookup</span>
          </li>
          <li>
            <code>modification_allowed</code> - a boolean field indicating if user is allowed to modify this group.
            <span class="warning">This is a couple of additional database lookups as this depends on user relations to
              the group's workgroup.</span>
          </li>
          <li>
            <code>all_tags</code> - a list of all tags attached to the group directly plus all the tags attached to all
            parent groups (inherited
            tags).
            <span class="warning">This is a potentially heavy request as it makes recursive group lookups.</span>
          </li>
          <li>
            <code>all_custom_fields</code> - a list of all custom fields attached to the group directly plus all the
            custom fields attached to all parent
            groups (inherited custom fields).
            <span class="warning">This is a potentially heavy request as it makes recursive group lookups.</span>
          </li>
          <li>
            <code>work_group_name</code> - a group's workgroup name as a string. This is a shortcut to reduce the response
            size in case you need only workgroup's
            name not the whole workgroup object, made primarily for the web ui.
            <span class="warning">This is an additional database lookup</span>
          </li>
        </ul>
      </p>
      <hr />
      <code class="handler">GET
        <a href="/api/v1/groups/:id" target="_blank">
          /api/v1/groups/:id
        </a>
      </code>
      <p>
        Behaves exactly as the groups list handler but for only one group identified by
        <code>:id</code> parameter which can be both
        <code>_id</code> or
        <code>name</code> as group name is also unique. Response behaves exactly the same so you get a list of groups
        with only one element.
        <code>_fields</code> parameter is relevant here as well however
        <code>_filter</code> is prohibited.
      </p>
      <hr />
      <code class="handler">POST
        <a href="/api/v1/groups/" target="_blank">
          /api/v1/groups/
        </a>
      </code>
      <p>
        Creates a group with a given JSON payload. Group has to belong to a workgroup which can be indicated by
        <code>work_group_id</code> field of payload or by
        <code>work_group_name</code> field if you find it more convenient. Both methods are equal.
      </p>
      <p>
        Group can be created only if user is a member of the workgroup the group is going to belong to.
      </p>
      <hr />
      <code class="handler">PUT
        <a href="/api/v1/groups/:id" target="_blank">
          /api/v1/groups/:id
        </a>
      </code>
      <p>
        Updates a group with a given id which is supposed to be
        <code>_id</code> or
        <code>name</code> of the group being updated with JSON payload. Note that
        <code>child_ids</code> and
        <code>parent_ids</code> can not be modified with this handler as they required a lot more work to do with
        connecting and disconnecting graph
        nodes and may confuse if are not in a separated handler.
      </p>
      <p>
        Group can be modified only if user is a member of the workgroup the group belongs to.
      </p>
      <hr />
      <code class="handler">DELETE
        <a href="/api/v1/groups/:id" target="_blank">
          /api/v1/groups/:id
        </a>
      </code>
      <p>
        Deletes a group with a given id which is supposed to be
        <code>_id</code> or
        <code>name</code> of the group being updated with JSON payload. The group can't be deleted if it has
        connections to other groups or
        hosts so you have to drop those connections first.
      </p>
      <p>
        Group can be deleted only if user is a member of the workgroup the group belongs to.
      </p>
      <hr />
      <code class="handler">PUT
        <a href="/api/v1/groups/:id/set_children" target="_blank">
          /api/v1/groups/:id/set_children
        </a>
      </code>
      <p>
        Modifies the set of group's children. Children IDs must be given in a
        <code>child_ids</code> field of JSON payload as a list of IDs.
      </p>
      <p>
        Modifies group's children only if user is a member of the workgroup the group belongs to.
      </p>
      <hr />
      <code class="handler">PUT
        <a href="/api/v1/groups/:id/set_hosts" target="_blank">
          /api/v1/groups/:id/set_hosts
        </a>
      </code>
      <p>
        Modifies the set of hosts directly included into the group. Host IDs must be given in a
        <code>host_ids</code> field of JSON payload as a list of IDs. Note that a host can be included only in one
        group directly. This particularly
        means that hosts listed in your request lose membership in groups they belonged to before.
      </p>
      <p>
        Modifies group's hosts only if user is a member of the workgroup the group belongs to.
      </p>
      <hr />

      <code class="handler">POST
        <a href="/api/v1/groups/:id/set_custom_fields" target="_blank">
          /api/v1/groups/:id/set_custom_fields
        </a>
      </code>
      <p>
        Updates a custom field list of a group identified by
        <code>:id</code> param which can be both
        <code>_id</code> or
        <code>name</code> according to JSON payload like
        <code>{"custom_fields": [{"key": ..., "value": ...}, {"key": ..., "value": ...}]}</code> or in an object way
        like
        <code>{"custom_fields": { "key1": "value1", "key2": "value2", ...}}</code>.
      </p>
      <p>
        If the group already has a custom field with a specified key, the value of that custom field will be replaced
        with the new one.
        New keys are added to custom fields list in the usual way.
      </p>
      <p>
        Modifies the group only if user is a member of the workgroup the group belongs to.
      </p>
      <hr />

      <code class="handler">POST
        <a href="/api/v1/groups/:id/remove_custom_fields" target="_blank">
          /api/v1/groups/:id/remove_custom_fields
        </a>
      </code>
      <p>
        Removes specified custom fields from a group identified by
        <code>:id</code> param which can be both
        <code>_id</code> or
        <code>name</code> according to JSON payload like
        <code>{"custom_fields": [{"key": ... }, {"key": ...}]}</code> or in an object way like
        <code>{"custom_fields": { "key1": &lt;any value&gt;, "key2": &lt;any value&gt;, ...}}</code>.
      </p>
      <p>
        If the group doesn't have a custom field with a specified key, the key will be ignored.
      </p>
      <p>
        Modifies the group only if user is a member of the workgroup the group belongs to.
      </p>
      <hr />

      <code class="handler">POST
        <a href="/api/v1/groups/:id/add_tags" target="_blank">
          /api/v1/groups/:id/add_tags
        </a>
      </code>
      <p>
        Adds a list of tags to a group identified by
        <code>:id</code> param which can be both
        <code>_id</code> or
        <code>name</code> according to JSON payload like
        <code>{"tags": ["tag1", "tag2", ...]}</code>.
      </p>
      <p>
        If the group already has a tag provided, the tag will be ignored as the list of tags must be unique.
      </p>
      <p>
        Modifies the group only if user is a member of the workgroup the group belongs to.
      </p>
      <hr />

      <code class="handler">POST
        <a href="/api/v1/groups/:id/remove_tags" target="_blank">
          /api/v1/groups/:id/remove_tags
        </a>
      </code>
      <p>
        Removes a given list of tags from a group identified by
        <code>:id</code> param which can be both
        <code>_id</code> or
        <code>name</code> according to JSON payload like
        <code>{"tags": ["tag1", "tag2", ...]}</code>.
      </p>
      <p>
        If the group doesn't have a tag provided for deletion, the tag will be ignored.
      </p>
      <p>
        Modifies the group only if user is a member of the workgroup the group belongs to.
      </p>
      <hr />

      <code class="handler">POST
        <a href="/api/v1/groups/mass_move" target="_blank">
          /api/v1/groups/mass_move
        </a>
      </code>
      <p>
        Accepts JSON payload like
        <code>{ "group_ids": [...], "work_group_id": "..." }</code> and moves all listed groups to the new workgroup. Groups
        are detached from their parents as parents remain in previous
        workgroup so can't be connected anymore.
      </p>
      <p>
        Groups are moved if user has a membership in all the workgroups all the groups belong to. User don't have to have
        a membership
        in a target workgroup so one should be aware that in this case user loses control over the groups he's just
        moved.
        This works like giving away without any way to get groups back without help of target workgroup members.
      </p>
      <hr />
      <code class="handler">POST
        <a href="/api/v1/groups/mass_delete" target="_blank">
          /api/v1/groups/mass_delete
        </a>
      </code>
      <p>
        Accepts JSON payload like
        <code>{ "group_ids": [...] }</code> and deletes all listed groups. All the children and hosts are being
        detached from the groups being deleted.
      </p>
      <p>
        Groups are deleted if user has a membership in all the workgroups all the groups belong to.
      </p>
      <hr />
      <code class="handler">GET
        <a href="/api/v1/groups/:id/structure" target="_blank">
          /api/v1/groups/:id/structure
        </a>
      </code>
      <p>
        Returns a tree-like structure with indicated group as a root. Every group in the structure has
        <code>children</code> field containing all child groups,
        <code>parents</code> field, containing parent groups, and
        <code>hosts</code> field, containing hosts included into group directly.
      </p>
      <p>Target group is identified by
        <code>:id</code> parameter which can be both
        <code>_id</code> or
        <code>name</code> as group name is also unique.
      </p>
      <p>Accepts
        <code>_fields</code> and
        <code>_host_fields</code> query string parameters, optionally allowing to limit response to particular fields
        for each model correspondingly.
      </p>
      <p>This is potentially very heavy request as it's fetching groups and hosts recursively</p>
    </section>
    <hr />
    <section>
      <a name="hosts"></a>
      <h2>Hosts API</h2>
      <p>
        Hosts API allows user to manipulate hosts. A host may be included in exactly one group. A host may also be
        attached to a
        datacenter.
      </p>
      <p>Hosts may have their own tags and custom fields, extending or overwriting tags and custom fields derived from
        groups
        hosts included in. Refer to
        <a href="#groups">Groups API</a> section for more info on tags and custom fields.</p>
      <p>
        Hosts have unique FQDNs and may have a list of aliases which don't have to be unique. Aliases are indexed and
        easy to be
        searched by.
      </p>
      <code class="handler">GET
        <a href="/api/v1/hosts/" target="_blank">
          /api/v1/hosts/
        </a>
      </code>
      <p>
        Provides a paginated list of hosts. Read more about pagination in
        <a href="#pagination">Pagination</a> section of this doc. List may be filtered by host fqdn using
        <code>_filter</code> query parameter. This accepts a string which is used as a prefix of host fqdn. Filters
        shorter than 2 symbols are
        ignored. Filters may be a quite heavy feature as they use regexp full scan on a MongoDB collection.
      </p>
      <p>
        <code>_fields</code> field helps to reduce size of the response allowing you to choose which fields to show.
        Accepts comma-separated
        list of field names. Available host fields are:
        <ul class="fieldlist">
          <li>
            <code>_id</code> - a unique id of the host
          </li>
          <li>
            <code>fqdn</code> - a unique fqdn (fully qualified domain name) of the host
          </li>
          <li>
            <code>description</code> - a description of the host. Can be null.
          </li>
          <li>
            <code>created_at</code> - datetime of the model creation.
          </li>
          <li>
            <code>updated_at</code> - datetime of the last model update.
          </li>
          <li>
            <code>group_id</code> - id of the group the host belongs to. Can be null.
          </li>
          <li>
            <code>datacenter_id</code> - id of the datacenter the host belongs to. Can be null.
          </li>
          <li>
            <code>aliases</code> - a list of host's aliases
          </li>
          <li>
            <code>tags</code> - a list of tags attached to the host directly
          </li>
          <li>
            <code>custom_fields</code> - a list of custom fields attached to the host directly.
          </li>
          <li>
            <code>group</code> - host's group as an object. If
            <code>group_id</code> is null which is allowed,
            <code>group</code> also returns null.
            <span class="warning">This is an additional database lookup</span>
          </li>
          <li>
            <code>group_name</code> - host's group name as a string. It's a shortcut for group.name, useful when you
            don't need the entire group
            object.
            <span class="warning">This is an additional database lookup</span>
          </li>
          <li>
            <code>datacenter</code> - the datacenter of the host as an object. If
            <code>datacenter_id</code>> is null,
            <code>datacenter</code> returns null as well.
            <span class="warning">This is an additional database lookup</span>
          </li>
          <li>
            <code>datacenter_name</code> - host's datacenter name as a string. It's a shortcut for datacenter.name,
            useful when you don't need the entire
            datacenter object.
            <span class="warning">This is an additional database lookup</span>
          </li>
          <li>
            <code>location</code> - is an alias to
            <code>datacenter</code> field.
          </li>
          <li>
            <code>location_name</code> - is an alias to
            <code>datacenter_name</code>
          </li>
          <li>
            <code>root_datacenter</code> - the root parent of the datacenter host belongs to as an object.
            <span class="warning">This is 2 additional database lookups</span>
          </li>
          <li>
            <code>root_datacenter_name</code> - a shortcut to
            <code>root_datacenter.name</code> useful when you don't need the entire datacenter object.
            <span class="warning">This is 2 additional database lookups</span>
          </li>
          <li>
            <code>root_location</code> - an alias to
            <code>root_datacenter</code>
          </li>
          <li>
            <code>root_location_name</code> - an alias to
            <code>root_datacenter_name</code>
          </li>
          <li>
            <code>modification_allowed</code> - boolean field indicating if current user has permissions to modify this
            host.
          </li>
          <li>
            <code>destruction_allowed</code> - boolean field indicating if current user has permissions to delete this
            host.
          </li>
          <li>
            <code>all_tags</code> - a list of all tags attached to the host directly plus all the tags attached to its
            group and all parent groups
            (inherited tags).
            <span class="warning">This is a potentially heavy request as it makes recursive group lookups.</span>
          </li>
          <li>
            <code>all_custom_fields</code> - a list of all custom fields attached to the host directly plus all the
            custom fields attached to its group
            and all parent groups (inherited custom fields).
            <span class="warning">This is a potentially heavy request as it makes recursive group lookups.</span>
          </li>
        </ul>
      </p>
      <hr />
      <code class="handler">GET
        <a href="/api/v1/hosts/:id" target="_blank">
          /api/v1/hosts/:id
        </a>
      </code>
      <p>
        Behaves exactly as the hosts list handler but for only one host identified by
        <code>:id</code> parameter which can be both
        <code>_id</code> or
        <code>fqdn</code> as host fqdn is also unique. Response behaves exactly the same so you get a list of hosts
        with only one element.
        <code>_fields</code> parameter is relevant here as well however
        <code>_filter</code> is prohibited.
      </p>
      <hr />
      <code class="handler">POST
        <a href="/api/v1/hosts/">/api/v1/hosts/</a>
      </code>
      <p>
        Creates a host or a list of hosts depending on JSON payload.
      </p>
      <p>
        There are two methods of creating host(s):
      </p>
      <ol>
        <li>Pass a JSON object with the host's fields. The only field required is
          <code>fqdn</code>, others are optional</li>
        <li>Pass a JSON object just like before but instead of
          <code>fqdn</code> field use
          <code>fqdn_pattern</code>
        </li>
      </ol>
      <p>
        The second aption allows you to create a list of hosts matching fqdn pattern. The pattern allows to use range
        and list expressions
        in square brackets.
        <h4>List expressions</h4>
        List expressions are comma-separated lists of values.
        <code>host[1,2,3].example.com</code> pattern will generate 3 hosts with FQDNs
        <code>host1.example.com</code>,
        <code>host2.example.com</code> and
        <code>host3.example.com</code> correspondingly.
        <h4>Range expressions</h4>
        Range expressions are two values delimited by a hyphen.
        <code>host[1-3].example.com</code> will give you the same result as in the list expression example above.
      </p>
      <p>
        Note that range expressions behave like Ruby ranges although may differ being implemented in python from
        scratch. This means
        that you can create ranges like
        <code>[a-e]</code> ===
        <code>a,b,c,d,e</code> or even
        <code>[a0-b9]</code> ===
        <code>a0,a1,a2,a3...a9,b0,b1,...,b9</code>
      </p>
      <p>
        You can use as many expressions as you want in
        <code>fqdn_pattern</code>. Combining them lets you create really huge group of servers in one step. For
        example,
        <code>service-[back,front][0-9][a-c].example.com</code>. If you use Inventoree Web UI, the host creation page
        will give you a brief list of result FQDNs if you start typing
        an FQDN pattern.
      </p>

      <p>
        In case of providing
        <code>group_id</code> field, host(s) will be created in the chosen group however this will require user's
        permissions to modify this group.
        By default new hosts are groupless and datacenterless to make it easier for automated provisioning systems to
        create
        new hosts in Inventoree via API. In most cases it's up to a system administrator how to markup servers and
        combine
        them into groups.
      </p>
      <hr />
      <code class="handler">PUT
        <a href="/api/v1/hosts/:id" target="_blank">
          /api/v1/hosts/:id
        </a>
      </code>
      <p>
        Updates a host identified by
        <code>:id</code> param which can be both
        <code>_id</code> or
        <code>fqdn</code> as host's fqdn has to be unique.
      </p>
      <p>
        To modify host user has to have permissions. Host in a group can be modified if user has permissions to modify
        that group.
        Groupless hosts are editable for everyone however if you want to change host's group_id, i.e. put a groupless
        host
        into a group, you have to have permissions to modify the target group. To move host from one group to another
        permissions
        for both source and target groups are required.
      </p>
      <p>
        Note that <code>tags</code> and <code>custom_fields</code> lists are fully replaced with the data given in the
        payload.
        If you want to manipulate tags and custom fields in a more flexible way, use
        <code>/api/v1/hosts/:id/set_custom_fields</code>,
        <code>/api/v1/hosts/:id/remove_custom_fields</code>,
        <code>/api/v1/hosts/:id/add_tags</code> and
        <code>/api/v1/hosts/:id/remove_tags</code> handlers described below.
      </p>
      <hr />

      <code class="handler">POST
        <a href="/api/v1/hosts/:id/set_custom_fields" target="_blank">
          /api/v1/hosts/:id/set_custom_fields
        </a>
      </code>
      <p>
        Updates a custom field list of a host identified by
        <code>:id</code> param which can be both
        <code>_id</code> or
        <code>fqdn</code> according to JSON payload like
        <code>{"custom_fields": [{"key": ..., "value": ...}, {"key": ..., "value": ...}]}</code> or in an object way
        like
        <code>{"custom_fields": { "key1": "value1", "key2": "value2", ...}}</code>.
      </p>
      <p>
        If the host already has a custom field with a specified key, the value of that custom field will be replaced
        with the new one.
        New keys are added to custom fields list in the usual way.
      </p>
      <p>
        To modify host user has to have permissions. Host in a group can be modified if user has permissions to modify
        that group. Groupless hosts are editable for everyone.
      </p>
      <hr />

      <code class="handler">POST
        <a href="/api/v1/hosts/:id/remove_custom_fields" target="_blank">
          /api/v1/hosts/:id/remove_custom_fields
        </a>
      </code>
      <p>
        Removes specified custom fields from a host identified by
        <code>:id</code> param which can be both
        <code>_id</code> or
        <code>fqdn</code> according to JSON payload like
        <code>{"custom_fields": [{"key": ... }, {"key": ...}]}</code> or in an object way like
        <code>{"custom_fields": { "key1": &lt;any value&gt;, "key2": &lt;any value&gt;, ...}}</code>.
      </p>
      <p>
        If the host doesn't have a custom field with a specified key, the key will be ignored.
      </p>
      <p>
        To modify host user has to have permissions. Host in a group can be modified if user has permissions to modify
        that group. Groupless hosts are editable for everyone.
      </p>
      <hr />

      <code class="handler">POST
        <a href="/api/v1/hosts/:id/add_tags" target="_blank">
          /api/v1/hosts/:id/add_tags
        </a>
      </code>
      <p>
        Adds a list of tags to a host identified by
        <code>:id</code> param which can be both
        <code>_id</code> or
        <code>fqdn</code> according to JSON payload like
        <code>{"tags": ["tag1", "tag2", ...]}</code>.
      </p>
      <p>
        If the host already has a tag provided, the tag will be ignored as the list of tags must be unique.
      </p>
      <p>
        To modify host user has to have permissions. Host in a group can be modified if user has permissions to modify
        that group. Groupless hosts are editable for everyone.
      </p>
      <hr />

      <code class="handler">POST
        <a href="/api/v1/hosts/:id/remove_tags" target="_blank">
          /api/v1/hosts/:id/remove_tags
        </a>
      </code>
      <p>
        Removes a given list of tags from a host identified by
        <code>:id</code> param which can be both
        <code>_id</code> or
        <code>fqdn</code> according to JSON payload like
        <code>{"tags": ["tag1", "tag2", ...]}</code>.
      </p>
      <p>
        If the host doesn't have a tag provided for deletion, the tag will be ignored.
      </p>
      <p>
        To modify host user has to have permissions. Host in a group can be modified if user has permissions to modify
        that group. Groupless hosts are editable for everyone.
      </p>
      <hr />

      <code class="handler">DELETE
        <a href="/api/v1/hosts/:id" target="_blank">
          /api/v1/hosts/:id
        </a>
      </code>
      <p>
        Deletes a host identified by
        <code>:id</code> param which can be both
        <code>_id</code> or
        <code>fqdn</code> as host's fqdn has to be unique.
      </p>
      <p>
        To modify host user has to have permissions. Host in a group can be deleted if user has permissions to modify
        that group.
        Groupless hosts can be deleted only by supervisors.
      </p>
      <hr />
      <code class="handler">POST
        <a href="/api/v1/hosts/mass_move" target="_blank">
          /api/v1/hosts/mass_move
        </a>
      </code>
      <p>
        The handler moves a list of hosts to a new group. Accepts JSON payload
        <code>{ "host_ids": [...], "group_id": "..." }</code>.
      </p>
      <p>
        User has to have permissions to modify every host in the given list to perform the operation. Also modification
        permissions
        for the target group are required.
      </p>
      <hr />
      <code class="handler">POST
        <a href="/api/v1/hosts/mass_set_datacenter" target="_blank">
          /api/v1/hosts/mass_set_datacenter
        </a>
      </code>
      <p>
        The handler moves a list of hosts to a new datacenter. Accepts JSON payload
        <code>{ "host_ids": [...], "datacenter_id": "..." }</code>.
      </p>
      <p>
        User has to have permissions to modify every host in the given list to perform the operation.
      </p>
      <hr />
      <code class="handler">POST
        <a href="/api/v1/hosts/mass_detach" target="_blank">
          /api/v1/hosts/mass_detach
        </a>
      </code>
      <p>
        The handler makes a list of hosts groupless. Accepts JSON payload
        <code>{ "host_ids": [...] }</code>.
      </p>
      <p>
        User has to have permissions to modify every host in the given list to perform the operation.
      </p>
      <hr />
      <code class="handler">POST
        <a href="/api/v1/hosts/mass_delete" target="_blank">
          /api/v1/hosts/mass_delete
        </a>
      </code>
      <p>
        The handler deletes a list of hosts according to JSON payload
        <code>{ "host_ids": [...] }</code>.
      </p>
      <p>
        User has to have permissions to delete every host in the given list to perform the operation.
      </p>
    </section>
    <hr />
    <section>
      <a name="open"></a>
      <h2>Open API</h2>
      <p>
        Open API contains a set of handlers of different nature. The only thing they have in common is that they don't
        require any
        authentication, thus, are read-only.
      </p>
      <code class="handler">GET 
        <a href="/api/v1/open/executer_data">
          /api/v1/open/executer_data
        </a>
      </code>
      <p>
        Returns a structure containing groups, hosts, workgroups and datacenters in format compatible with
        <a href="https://github.com/viert/xcute" target="_blank">XCute</a> CLI (and is commonly used exactly by xcute
        in fact)
      </p>
      <p>
        Accepts a number of query string parameters:
      </p>
      <p>
        <code>work_groups</code> - comma-separated list of workgroup names to limit the output to.
      </p>
      <p>
        <code>recursive</code> - a boolean field indicating that
        <code>all_tags</code>> and
        <code>all_custom_fields</code> are attached to all groups and hosts in output. This makes the request quite
        heavy otherwise powerful.
      </p>
      <p>
        <code>include_unattached</code> - a boolean field indicating that all the hosts should be in the output no
        matter if they're attached to groups
        or not. If this value is false, groupless hosts are ignored.
      </p>
      <hr />
      <code class="handler">GET
        <a href="/api/v1/open/ansible">/api/v1/open/ansible</a>
      </code>
      <p>Returns hosts attached to groups in
        <a href="https://www.ansible.com">ansible</a> inventory-file format.
      </p>
      <p>
        Accepts:<br />
        <code>work_groups</code> query string parameter - a comma-separated list of workgroup names allowing to limit the
        output to the given workgroups. <br />
        <code>vars</code> query parameter which can be set to <code>true</code>, <code>yes</code> or <code>1</code> for
        true value otherwise it's false.
        This indicates if the output should contain host variables for ansible inventory.<br />
        <code>format</code> query string parameter which can be either <code>plain</code> or <code>json</code>.
        The default value is <code>plain</code> for backward compatibility purposes. Plain inventory should be saved to
        text file to use with ansible while
        JSON version can be used as a dynamic provider according to <a target="_blank" href="https://docs.ansible.com/ansible/2.5/dev_guide/developing_inventory.html">this
          doc</a>.
      </p>
      <hr />
      <code class="handler">GET
        <a href="/api/v1/open/app">/api/v1/open/app</a>
      </code>
      <p>
        Returns a brief application info including app version and versions of frameworks and services used by the app
        like Flask
        or MongoDB.
      </p>
      <hr />
      <code class="handler">GET
        <a href="/api/v1/open/resolve_hosts">/api/v1/open/resolve_hosts</a>
      </code>
      <p>
        Accepts
        <code>groups</code> and
        <code>tags</code> query string parameters and returns a list of hosts in the grouplist provided optionally
        filtered by a tag list.
        Also accepts
        <code>fields</code> parameter limiting host model to the specified field list.
      </p>

    </section>
    <hr />
    <section>
      <a name="work_groups"></a>
      <h2>WorkGroups API</h2>
      <p>
        WorkGroups API allows user to manipulate workgroups. WorkGroups are high level models connecting users with all the
        structures Inventoree has.
      </p>
      <code class="handler">GET
        <a href="/api/v1/work_groups/" target="_blank">
          /api/v1/work_groups/
        </a>
      </code>
      <p>
        Provides a paginated list of workgroups. Read more about pagination in
        <a href="#pagination">Pagination</a> section of this doc. List may be filtered by workgroup name using
        <code>_filter</code> query parameter. This accepts a string which is used as a prefix of workgroup name. Filters
        shorter than 2 symbols
        are ignored. Filters may be a quite heavy feature as they use regexp full scan on a MongoDB collection.
      </p>
      <p>
        <code>_fields</code> field helps to reduce size of the response allowing you to choose which fields to show.
        Accepts comma-separated
        list of field names. Available host fields are:
      </p>
      <ul class="fieldlist">
        <li>
          <code>_id</code> - a unique id of the workgroup
        </li>
        <li>
          <code>name</code> - a unique name of the workgroup
        </li>
        <li>
          <code>description</code> - a description of the workgroup. Can be null
        </li>
        <li>
          <code>email</code> - a email associated with the workgroup. Can be null
        </li>
        <li>
          <code>root_email</code> - in first versions of conductor this field used to keep the address for root email
          for servers in the workgroup.
          Can be null.
        </li>
        <li>
          <code>owner_id</code> - this is an ID of the workgroup's owner (user)
        </li>
        <li>
          <code>members_id</code> - this is a list of IDs of workgroup's members (users as well)
        </li>
        <li>
          <code>created_at</code> - datetime of the model creation.
        </li>
        <li>
          <code>updated_at</code> - datetime of the last model update.
        </li>
        <li>
          <code>owner</code> - workgroup's owner as an object.
          <span class="warning">This is an additional database lookup</span>
        </li>
        <li>
          <code>owner_name</code> - a shortcut to owner.name
          <span class="warning">This is an additional database lookup</span>
        </li>
        <li>
          <code>members</code> - a list of workgroup's members as objects.
          <span class="warning">This is an additional database lookup</span>
        </li>
        <li>
          <code>member_usernames</code> - a list of workgroup's member names.
          <span class="warning">This is an additional database lookup</span>
        </li>
        <li>
          <code>modification_allowed</code> - a boolean field indicating if current user has permissions to modify the
          workgroup
        </li>
        <li>
          <code>member_list_modification_allowed</code> - a boolean field indicating if current user has permissions to
          modify the workgroup's member list
        </li>
        <li>
          <code>groups_count</code> - a number of groups in the workgroup
          <span class="warning">This is an additional database lookup</span>
        </li>
        <li>
          <code>groups</code> - a list of groups included in the workgroup as objects
          <span class="warning">This is an additional database lookup</span>
        </li>
      </ul>
      <hr />
      <code class="handler">GET
        <a href="/api/v1/work_groups/:id" target="_blank">
          /api/v1/work_groups/:id
        </a>
      </code>
      <p>
        Behaves exactly as the workgroup list handler but for only one workgroup identified by
        <code>:id</code> parameter which can be both
        <code>_id</code> or
        <code>name</code> as workgroup name is also unique. Response behaves exactly the same so you get a list of
        workgroups with only one element.
        <code>_fields</code> parameter is relevant here as well however
        <code>_filter</code> is prohibited.
      </p>
      <hr />
      <code class="handler">POST
        <a href="/api/v1/work_groups/" target="_blank">
          /api/v1/work_groups/
        </a>
      </code>
      <p>
        Creates a work_group with a given JSON payload. WorkGroup's owner is being set automatically and equals to current
        user.
      </p>
      <hr />
      <code class="handler">PUT
        <a href="/api/v1/work_groups/:id" target="_blank">
          /api/v1/work_groups/:id
        </a>
      </code>
      <p>
        Updates a workgroup with a given id which is supposed to be
        <code>_id</code> or
        <code>name</code> of the workgroup being updated with JSON payload. Note that
        <code>member_ids</code> and
        <code>owner_id</code> can not be modified this way.
      </p>
      <p>
        A workgroup can be modified only if user is a workgroup's member or has supervisor privileges.
      </p>
      <hr />
      <code class="handler">DELETE
        <a href="/api/v1/work_groups/:id" target="_blank">
          /api/v1/work_groups/:id
        </a>
      </code>
      <p>
        Deletes a workgroup with a given id which is supposed to be
        <code>_id</code> or
        <code>name</code> of the workgroup.
      </p>
      <p>
        A workgroup can be deleted only if user is a workgroup's owner or has supervisor privileges.
      </p>
      <hr />
      <code class="handler">POST
        <a href="/api/v1/work_groups/:id/add_member" target="_blank">
          /api/v1/work_groups/:id/add_member
        </a>
      </code>
      <p>
        Adds a workgroup's member according to JSON payload
        <code>{ "user_id": "..." }</code>
      </p>
      <p>
        Member lists can only be modified by workgroup's owner or a user with supervisor privileges.
      </p>
      <hr />
      <code class="handler">POST
        <a href="/api/v1/work_groups/:id/remove_member" target="_blank">
          /api/v1/work_groups/:id/remove_member
        </a>
      </code>
      <p>
        Removes a workgroup's member according to JSON payload
        <code>{ "user_id": "..." }</code>
      </p>
      <p>
        Member lists can only be modified by workgroup's owner or a user with supervisor privileges.
      </p>
      <hr />
      <code class="handler">POST
        <a href="/api/v1/work_groups/:id/set_members" target="_blank">
          /api/v1/work_groups/:id/set_members
        </a>
      </code>
      <p>
        Re-sets workgroup's members according to JSON payload
        <code>{ "member_ids": [...] }</code>. Note that the handler completely replaces the current member list.
      </p>
      <p>
        Member lists can only be modified by workgroup's owner or a user with supervisor privileges.
      </p>
      <hr />
      <code class="handler">POST
        <a href="/api/v1/work_groups/:id/switch_owner" target="_blank">
          /api/v1/work_groups/:id/switch_owner
        </a>
      </code>
      <p>
        Changes the workgroup owner to a given user according to JSON payload
        <code>{ "owner_id": "..." }</code>.
      </p>
      <p>
        Owner can be changed either by the current owner or by a user with supervisor privileges.
      </p>
    </section>
    <hr />
    <section>
      <a name="users"></a>
      <h2>Users API</h2>
      <p>
        Users API allows to manipulate inventoree users. Note that in most cases of using external auth users are
        created automatically.
        However to get control over users you'll need either a local auth user with supervisor privileges created with
        <code>inventoree shell</code> or an external auth user granted with supervisor privileges with
        <code>inventoree shell</code> as well.
      </p>
      <code class="handler">
        GET <a href="/api/v1/users/">/api/v1/users</a>
      </code>
      <p>
        Provides a paginated list of users. Read more about pagination in
        <a href="#pagination">Pagination</a> section of this doc. List may be filtered by user username using
        <code>_filter</code> query parameter. This accepts a string which is used as a prefix of user's username.
        Filters shorter than 2 symbols
        are ignored. Filters may be a quite heavy feature as they use regexp full scan on a MongoDB collection.
      </p>
      <p>
        <code>_fields</code> field helps to reduce size of the response allowing you to choose which fields to show.
        Accepts comma-separated
        list of field names. Available host fields are:
      </p>
      <ul class="fieldlist">
        <li>
          <code>_id</code> - a unique id of user
        </li>
        <li>
          <code>username</code> - a unique username
        </li>
        <li>
          <code>first_name</code> - user's first name
        </li>
        <li>
          <code>last_name</code> - user's last name
        </li>
        <li>
          <code>email</code> - user's email
        </li>
        <li>
          <code>avatar_url</code> - user's avatar image url
        </li>
        <li>
          <code>supervisor</code> - a boolean field indicating if user has supervisor privileges
        </li>
        <li>
          <code>ext_id</code> - a string indexed field containing a unique user's id in external auth system. Used in
          external auth plugins.
        </li>
        <li>
          <code>custom_data</code> - an object field with optional custom data related to user derived from external
          auth system. Used in external
          auth plugins.
        </li>
        <li>
          <code>created_at</code> - datetime of the model creation.
        </li>
        <li>
          <code>updated_at</code> - datetime of the last model update.
        </li>
        <li>
          <code>work_groups_owned</code> - a list of workgroups owned by user as objects.
          <span class="warning">This is an additional database lookup</span>
        </li>
        <li>
          <code>work_groups_included_into</code> - a list of workgroups user is a member of.
          <span class="warning">This is an additional database lookup</span>
        </li>
        <li>
          <code>modification_allowed</code> - a boolean field indicating if the current user has permissions to modify
          the listed user.
        </li>
        <li>
          <code>supervisor_set_allowed</code> - a boolean field indicating if the current user has permissions to grant
          the listed user supervisor privileges.
        </li>
      </ul>
      <hr />
      <code class="handler">
        GET <a href="/api/v1/users/:id">/api/v1/users/:id</a>
      </code>
      <p>
        Behaves exactly as the user list handler but for only one user identified by
        <code>:id</code> parameter which can be both
        <code>_id</code> or
        <code>username</code> as username is also unique. Response behaves exactly the same so you get a list of users
        with only one element.
        <code>_fields</code> parameter is relevant here as well however
        <code>_filter</code> is prohibited.
      </p>
      <hr />
      <code class="handler">
        POST <a href="/api/v1/users/">/api/v1/users/</a>
      </code>
      <p>
        Creates a user according to JSON payload. Note that you can't provide
        <code>password_hash</code> field that way which is the field where the bcrypt-based password hash is stored and
        actually you never need to
        manually access
        <code>password_hash</code> field.
      </p>
      <p>
        To provide a password for a new user, use
        <code>password_raw</code> and
        <code>password_raw_confirm</code> fields which have to match.
        <code>password_hash</code> will be calculated and stored during the user creation.
      </p>
    </section>
    <hr />
    <section>
      <a name="pagination"></a>
      <h3>Appendix A: Pagination</h3>
      <p>
        List handlers are paginated by default. This particularly means that the response data is located in
        <code>data</code> field of the JSON response and there are also three additional fields:
      </p>
      <ul class="fieldlist">
        <li>
          <code>count</code> - the
          <b>total</b> number of elements matching requested criteria, i.e. how many items you would get if it weren't
          paginated.
        </li>
        <li>
          <code>page</code> - the current page number
        </li>
        <li>
          <code>total_pages</code> - the number of pages matching the criteria.
        </li>
      </ul>
      <p>
        By default the page param equals to 1 (starts from 1, no programmers' stuff here). To get other pages just add
        <code>_page=[page_num]</code> to the request query string.
      </p>
      <p>
        You can also reduce or increase the page size using
        <code>_limit</code> query param like
        <code>_limit=30</code>. The default limit depends on the inventoree backend configuration (
        <code>DOCUMENTS_PER_PAGE</code> param in
        <code>app.py</code> config)
      </p>
      <p>
        In case you don't want to use pagination at all (can reduce performance), add
        <code>_nopaging=true</code> to the query string.
      </p>
    </section>

  </main>
</body>

</html>